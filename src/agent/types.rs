use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use solana_sdk::pubkey::Pubkey;
use rust_decimal::Decimal;

/// Market data and quotes from Jupiter API
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QuoteData {
    pub input_mint: String,
    pub output_mint: String,
    pub input_amount: u64,
    pub output_amount: u64,
    pub other_amount_threshold: u64,
    pub swap_mode: String,
    pub slippage_bps: u16,
    pub platform_fee_bps: u16,
    pub price_impact_pct: f64,
    pub route_plan: Vec<RoutePlan>,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RoutePlan {
    pub swap_info: SwapInfo,
    pub percent: u8,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapInfo {
    pub amm_key: String,
    pub label: String,
    pub input_mint: String,
    pub output_mint: String,
    pub in_amount: String,
    pub out_amount: String,
    pub fee_amount: String,
    pub fee_mint: String,
}

/// Trading strategy configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyConfig {
    pub strategy_type: StrategyType,
    pub parameters: StrategyParameters,
    pub risk_limits: RiskLimits,
    pub execution_settings: ExecutionSettings,
}

#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]
pub enum StrategyType {
    Arbitrage,
    GridTrading,
    DCA,
    MeanReversion,
    TrendFollowing,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyParameters {
    pub min_spread_bps: u16,
    pub max_slippage_bps: u16,
    pub position_size_usd: f64,
    pub rebalance_threshold_pct: f64,
    pub lookback_periods: u32,
    pub custom_params: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskLimits {
    pub max_position_size_usd: f64,
    pub max_daily_loss_pct: f64,
    pub max_drawdown_pct: f64,
    pub stop_loss_pct: f64,
    pub take_profit_pct: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionSettings {
    pub priority_fee_percentile: u8,
    pub max_priority_fee_lamports: u64,
    pub transaction_timeout_ms: u64,
    pub retry_attempts: u8,
    pub jito_tip_lamports: u64,
}

/// Trading plan generated by the agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradingPlan {
    pub id: uuid::Uuid,
    pub strategy_type: StrategyType,
    pub bucket_pubkey: Pubkey,
    pub input_mint: Pubkey,
    pub output_mint: Pubkey,
    pub input_amount: u64,
    pub min_output_amount: u64,
    pub max_slippage_bps: u16,
    pub priority_fee: u64,
    pub route_plan: Vec<u8>,
    pub confidence_score: f64,
    pub created_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
    pub execution_context: ExecutionContext,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionContext {
    pub market_conditions: MarketConditions,
    pub risk_assessment: RiskAssessment,
    pub ai_reasoning: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketConditions {
    pub volatility_24h: f64,
    pub volume_24h: f64,
    pub price_trend: PriceTrend,
    pub liquidity_score: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PriceTrend {
    Bullish,
    Bearish,
    Sideways,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RiskAssessment {
    pub risk_score: f64,
    pub max_loss_estimate: f64,
    pub position_risk_pct: f64,
    pub market_risk_factors: Vec<String>,
}

/// Performance metrics for learning and adaptation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceMetrics {
    pub total_trades: u64,
    pub successful_trades: u64,
    pub total_pnl: Decimal,
    pub win_rate: f64,
    pub avg_slippage_bps: f64,
    pub avg_execution_time_ms: u64,
    pub max_drawdown: f64,
    pub sharpe_ratio: f64,
    pub last_updated: DateTime<Utc>,
}

/// Agent state and configuration
#[derive(Debug, Clone, Serialize)]
pub struct AgentState {
    pub is_active: bool,
    #[serde(serialize_with = "serialize_pubkey_map")]
    pub current_positions: HashMap<Pubkey, Position>,
    pub performance: PerformanceMetrics,
    pub strategy_config: StrategyConfig,
    pub learning_parameters: LearningParameters,
    pub last_market_data: HashMap<String, QuoteData>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub bucket_pubkey: Pubkey,
    pub token_mint: Pubkey,
    pub amount: u64,
    pub entry_price: f64,
    pub current_price: f64,
    pub unrealized_pnl: f64,
    pub opened_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LearningParameters {
    pub learning_rate: f64,
    pub adaptation_window_hours: u32,
    pub performance_threshold: f64,
    pub parameter_bounds: HashMap<String, (f64, f64)>,
}

/// AI client request/response types
#[derive(Debug, Serialize)]
pub struct AIAnalysisRequest {
    pub market_data: Vec<QuoteData>,
    pub current_positions: Vec<Position>,
    pub strategy_config: StrategyConfig,
    pub performance_history: PerformanceMetrics,
    pub question: String,
}

#[derive(Debug, Deserialize)]
pub struct AIAnalysisResponse {
    pub recommendation: TradingRecommendation,
    pub reasoning: String,
    pub confidence: f64,
    pub risk_assessment: RiskAssessment,
    pub suggested_parameters: Option<HashMap<String, f64>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TradingRecommendation {
    Buy { amount: u64, target_price: f64 },
    Sell { amount: u64, target_price: f64 },
    Hold,
    Rebalance { adjustments: HashMap<String, f64> },
    StopLoss,
}

/// Error types for the agent system
#[derive(thiserror::Error, Debug)]
pub enum AgentError {
    #[error("No valid trading plan found: {0}")]
    NoOpportunity(String),
    #[error("Database error: {0}")]
    Database(String),
    #[error("Jupiter API error: {0}")]
    JupiterApi(String),
    
    #[error("AI analysis error: {0}")]
    AIAnalysis(String),
    
    #[error("Strategy execution error: {0}")]
    StrategyExecution(String),
    
    #[error("Risk limit exceeded: {0}")]
    RiskLimitExceeded(String),
    
    #[error("Insufficient funds: {0}")]
    InsufficientFunds(String),
    
    #[error("Transaction failed: {0}")]
    TransactionFailed(String),
    
    #[error("Market data stale: {0}")]
    StaleMarketData(String),
    
    #[error("Configuration error: {0}")]
    Configuration(String),
    
    #[error("Pubkey parsing error: {0}")]
    PubkeyParsing(#[from] solana_sdk::pubkey::ParsePubkeyError),
    
    #[error("Binary serialization error: {0}")]
    BinarySerialization(#[from] Box<bincode::ErrorKind>),
    
    #[error("Network error: {0}")]
    Network(#[from] reqwest::Error),
    
    #[error("Serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
}

/// Custom serializer to convert HashMap<Pubkey, Position> to HashMap<String, Position>
fn serialize_pubkey_map<S>(
    map: &HashMap<Pubkey, Position>,
    serializer: S,
) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    let string_map: HashMap<String, &Position> = map
        .iter()
        .map(|(k, v)| (k.to_string(), v))
        .collect();
    string_map.serialize(serializer)
}
